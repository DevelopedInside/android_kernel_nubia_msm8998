/* Copyright (c) 2011-2017, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

 //ZTEMT: zhouruoyu add for hi846 otp ---start
#include "msm_sensor.h"
#include "msm_sd.h"
#include "camera.h"
#include "msm_cci.h"
#include "msm_camera_dt_util.h"
#include "hi846_otp.h"

#undef CDBG
#define CDBG(fmt, args...) pr_debug(fmt, ##args)

#define MODULE_ID_SUNWIN 0x68
#define MODULE_ID_SBX 0x10

#define SEG1_FLAG_REG (0x0201 - 0x0201)
#define SEG2_FLAG_REG (0x0235 - 0x0201)
#define SEG3_FLAG_REG (0x0C5F - 0x0201)

#define SEG1_GROUP1_S (0x0202 - 0x0201)
#define SEG1_GROUP1_E (0x0212 - 0x0201)
#define SEG1_GROUP2_S (0x0213 - 0x0201)
#define SEG1_GROUP2_E (0x0223 - 0x0201)
#define SEG1_GROUP3_S (0x0224 - 0x0201)
#define SEG1_GROUP3_E (0x0234 - 0x0201)

#define SEG2_GROUP1_S (0x0236 - 0x0201)
#define SEG2_GROUP1_E (0x0598 - 0x0201)
#define SEG2_GROUP2_S (0x0599 - 0x0201)
#define SEG2_GROUP2_E (0x08FB - 0x0201)
#define SEG2_GROUP3_S (0x08FC - 0x0201)
#define SEG2_GROUP3_E (0x0C5E -0x0201)

#define SEG3_GROUP1_S (0x0C60 - 0x0201)
#define SEG3_GROUP1_E (0x0C7D - 0x0201)
#define SEG3_GROUP2_S (0x0C7E - 0x0201)
#define SEG3_GROUP2_E (0x0C9B - 0x0201)
#define SEG3_GROUP3_S (0x0C9C - 0x0201)
#define SEG3_GROUP3_E (0x0CB9 - 0x0201)

#define R_GR_TYPICAL_SUNWIN 0xDE
#define B_GB_TYPICAL_SUNWIN 0x14D

#define HI846_INIT_SETTING0 \
{ \
	{0x0A00, 0x0000,0x00},\
	{0x2000, 0x987A,0x00},\
	{0x2002, 0x00FF,0x00},\
	{0x2004, 0x0047,0x00},\
	{0x2006, 0x3FFF,0x00},\
	{0x2008, 0x3FFF,0x00},\
	{0x200A, 0xC216,0x00},\
	{0x200C, 0x1292,0x00},\
	{0x200E, 0xC01A,0x00},\
	{0x2010, 0x403D,0x00},\
	{0x2012, 0x000E,0x00},\
	{0x2014, 0x403E,0x00},\
	{0x2016, 0x0B80,0x00},\
	{0x2018, 0x403F,0x00},\
	{0x201A, 0x82AE,0x00},\
	{0x201C, 0x1292,0x00},\
	{0x201E, 0xC00C,0x00},\
	{0x2020, 0x4130,0x00},\
	{0x2022, 0x43E2,0x00},\
	{0x2024, 0x0180,0x00},\
	{0x2026, 0x4130,0x00},\
	{0x2028, 0x7400,0x00},\
	{0x202A, 0x5000,0x00},\
	{0x202C, 0x0253,0x00},\
	{0x202E, 0x0AD1,0x00},\
	{0x2030, 0x2360,0x00},\
	{0x2032, 0x0009,0x00},\
	{0x2034, 0x5020,0x00},\
	{0x2036, 0x000B,0x00},\
	{0x2038, 0x0002,0x00},\
	{0x203A, 0x0044,0x00},\
	{0x203C, 0x0016,0x00},\
	{0x203E, 0x1792,0x00},\
	{0x2040, 0x7002,0x00},\
	{0x2042, 0x154F,0x00},\
	{0x2044, 0x00D5,0x00},\
	{0x2046, 0x000B,0x00},\
	{0x2048, 0x0019,0x00},\
	{0x204A, 0x1698,0x00},\
	{0x204C, 0x000E,0x00},\
	{0x204E, 0x099A,0x00},\
	{0x2050, 0x0058,0x00},\
	{0x2052, 0x7000,0x00},\
	{0x2054, 0x1799,0x00},\
	{0x2056, 0x0310,0x00},\
	{0x2058, 0x03C3,0x00},\
	{0x205A, 0x004C,0x00},\
	{0x205C, 0x064A,0x00},\
	{0x205E, 0x0001,0x00},\
	{0x2060, 0x0007,0x00},\
	{0x2062, 0x0BC7,0x00},\
	{0x2064, 0x0055,0x00},\
	{0x2066, 0x7000,0x00},\
	{0x2068, 0x1550,0x00},\
	{0x206A, 0x158A,0x00},\
	{0x206C, 0x0004,0x00},\
	{0x206E, 0x1488,0x00},\
	{0x2070, 0x7010,0x00},\
	{0x2072, 0x1508,0x00},\
	{0x2074, 0x0004,0x00},\
	{0x2076, 0x0016,0x00},\
	{0x2078, 0x03D5,0x00},\
	{0x207A, 0x0055,0x00},\
	{0x207C, 0x08CA,0x00},\
	{0x207E, 0x2019,0x00},\
	{0x2080, 0x0007,0x00},\
	{0x2082, 0x7057,0x00},\
	{0x2084, 0x0FC7,0x00},\
	{0x2086, 0x5041,0x00},\
	{0x2088, 0x12C8,0x00},\
	{0x208A, 0x5060,0x00},\
	{0x208C, 0x5080,0x00},\
	{0x208E, 0x2084,0x00},\
	{0x2090, 0x12C8,0x00},\
	{0x2092, 0x7800,0x00},\
	{0x2094, 0x0802,0x00},\
	{0x2096, 0x040F,0x00},\
	{0x2098, 0x1007,0x00},\
	{0x209A, 0x0803,0x00},\
	{0x209C, 0x080B,0x00},\
	{0x209E, 0x3803,0x00},\
	{0x20A0, 0x0807,0x00},\
	{0x20A2, 0x0404,0x00},\
	{0x20A4, 0x0400,0x00},\
	{0x20A6, 0xFFFF,0x00},\
	{0x20A8, 0xF0B2,0x00},\
	{0x20AA, 0xFFEF,0x00},\
	{0x20AC, 0x0A84,0x00},\
	{0x20AE, 0x1292,0x00},\
	{0x20B0, 0xC02E,0x00},\
	{0x20B2, 0x4130,0x00},\
	{0x20B4, 0xF0B2,0x00},\
	{0x20B6, 0xFFBF,0x00},\
	{0x20B8, 0x2004,0x00},\
	{0x20BA, 0x403F,0x00},\
	{0x20BC, 0x00C3,0x00},\
	{0x20BE, 0x4FE2,0x00},\
	{0x20C0, 0x8318,0x00},\
	{0x20C2, 0x43CF,0x00},\
	{0x20C4, 0x0000,0x00},\
	{0x20C6, 0x9382,0x00},\
	{0x20C8, 0xC314,0x00},\
	{0x20CA, 0x2003,0x00},\
	{0x20CC, 0x12B0,0x00},\
	{0x20CE, 0xCAB0,0x00},\
	{0x20D0, 0x4130,0x00},\
	{0x20D2, 0x12B0,0x00},\
	{0x20D4, 0xC90A,0x00},\
	{0x20D6, 0x4130,0x00},\
	{0x20D8, 0x42D2,0x00},\
	{0x20DA, 0x8318,0x00},\
	{0x20DC, 0x00C3,0x00},\
	{0x20DE, 0x9382,0x00},\
	{0x20E0, 0xC314,0x00},\
	{0x20E2, 0x2009,0x00},\
	{0x20E4, 0x120B,0x00},\
	{0x20E6, 0x120A,0x00},\
	{0x20E8, 0x1209,0x00},\
	{0x20EA, 0x1208,0x00},\
	{0x20EC, 0x1207,0x00},\
	{0x20EE, 0x1206,0x00},\
	{0x20F0, 0x4030,0x00},\
	{0x20F2, 0xC15E,0x00},\
	{0x20F4, 0x4130,0x00},\
	{0x20F6, 0x1292,0x00},\
	{0x20F8, 0xC008,0x00},\
	{0x20FA, 0x4130,0x00},\
	{0x20FC, 0x42D2,0x00},\
	{0x20FE, 0x82A1,0x00},\
	{0x2100, 0x00C2,0x00},\
	{0x2102, 0x1292,0x00},\
	{0x2104, 0xC040,0x00},\
	{0x2106, 0x4130,0x00},\
	{0x2108, 0x1292,0x00},\
	{0x210A, 0xC006,0x00},\
	{0x210C, 0x42A2,0x00},\
	{0x210E, 0x7324,0x00},\
	{0x2110, 0x9382,0x00},\
	{0x2112, 0xC314,0x00},\
	{0x2114, 0x2011,0x00},\
	{0x2116, 0x425F,0x00},\
	{0x2118, 0x82A1,0x00},\
	{0x211A, 0xF25F,0x00},\
	{0x211C, 0x00C1,0x00},\
	{0x211E, 0xF35F,0x00},\
	{0x2120, 0x2406,0x00},\
	{0x2122, 0x425F,0x00},\
	{0x2124, 0x00C0,0x00},\
	{0x2126, 0xF37F,0x00},\
	{0x2128, 0x522F,0x00},\
	{0x212A, 0x4F82,0x00},\
	{0x212C, 0x7324,0x00},\
	{0x212E, 0x425F,0x00},\
	{0x2130, 0x82D4,0x00},\
	{0x2132, 0xF35F,0x00},\
	{0x2134, 0x4FC2,0x00},\
	{0x2136, 0x01B3,0x00},\
	{0x2138, 0x93C2,0x00},\
	{0x213A, 0x829F,0x00},\
	{0x213C, 0x2421,0x00},\
	{0x213E, 0x403E,0x00},\
	{0x2140, 0xFFFE,0x00},\
	{0x2142, 0x40B2,0x00},\
	{0x2144, 0xEC78,0x00},\
	{0x2146, 0x831C,0x00},\
	{0x2148, 0x40B2,0x00},\
	{0x214A, 0xEC78,0x00},\
	{0x214C, 0x831E,0x00},\
	{0x214E, 0x40B2,0x00},\
	{0x2150, 0xEC78,0x00},\
	{0x2152, 0x8320,0x00},\
	{0x2154, 0xB3D2,0x00},\
	{0x2156, 0x008C,0x00},\
	{0x2158, 0x2405,0x00},\
	{0x215A, 0x4E0F,0x00},\
	{0x215C, 0x503F,0x00},\
	{0x215E, 0xFFD8,0x00},\
	{0x2160, 0x4F82,0x00},\
	{0x2162, 0x831C,0x00},\
	{0x2164, 0x90F2,0x00},\
	{0x2166, 0x0003,0x00},\
	{0x2168, 0x008C,0x00},\
	{0x216A, 0x2401,0x00},\
	{0x216C, 0x4130,0x00},\
	{0x216E, 0x421F,0x00},\
	{0x2170, 0x831C,0x00},\
	{0x2172, 0x5E0F,0x00},\
	{0x2174, 0x4F82,0x00},\
	{0x2176, 0x831E,0x00},\
	{0x2178, 0x5E0F,0x00},\
	{0x217A, 0x4F82,0x00},\
	{0x217C, 0x8320,0x00},\
	{0x217E, 0x3FF6,0x00},\
	{0x2180, 0x432E,0x00},\
	{0x2182, 0x3FDF,0x00},\
	{0x2184, 0x421F,0x00},\
	{0x2186, 0x7100,0x00},\
	{0x2188, 0x4F0E,0x00},\
	{0x218A, 0x503E,0x00},\
	{0x218C, 0xFFD8,0x00},\
}

#define HI846_INIT_SETTING1 \
{ \
	{0x218E, 0x4E82,0x00},\
	{0x2190, 0x7A04,0x00},\
	{0x2192, 0x421E,0x00},\
	{0x2194, 0x831C,0x00},\
	{0x2196, 0x5F0E,0x00},\
	{0x2198, 0x4E82,0x00},\
	{0x219A, 0x7A06,0x00},\
	{0x219C, 0x0B00,0x00},\
	{0x219E, 0x7304,0x00},\
	{0x21A0, 0x0050,0x00},\
	{0x21A2, 0x40B2,0x00},\
	{0x21A4, 0xD081,0x00},\
	{0x21A6, 0x0B88,0x00},\
	{0x21A8, 0x421E,0x00},\
	{0x21AA, 0x831E,0x00},\
	{0x21AC, 0x5F0E,0x00},\
	{0x21AE, 0x4E82,0x00},\
	{0x21B0, 0x7A0E,0x00},\
	{0x21B2, 0x521F,0x00},\
	{0x21B4, 0x8320,0x00},\
	{0x21B6, 0x4F82,0x00},\
	{0x21B8, 0x7A10,0x00},\
	{0x21BA, 0x0B00,0x00},\
	{0x21BC, 0x7304,0x00},\
	{0x21BE, 0x007A,0x00},\
	{0x21C0, 0x40B2,0x00},\
	{0x21C2, 0x0081,0x00},\
	{0x21C4, 0x0B88,0x00},\
	{0x21C6, 0x4392,0x00},\
	{0x21C8, 0x7A0A,0x00},\
	{0x21CA, 0x0800,0x00},\
	{0x21CC, 0x7A0C,0x00},\
	{0x21CE, 0x0B00,0x00},\
	{0x21D0, 0x7304,0x00},\
	{0x21D2, 0x022B,0x00},\
	{0x21D4, 0x40B2,0x00},\
	{0x21D6, 0xD081,0x00},\
	{0x21D8, 0x0B88,0x00},\
	{0x21DA, 0x0B00,0x00},\
	{0x21DC, 0x7304,0x00},\
	{0x21DE, 0x0255,0x00},\
	{0x21E0, 0x40B2,0x00},\
	{0x21E2, 0x0081,0x00},\
	{0x21E4, 0x0B88,0x00},\
	{0x21E6, 0x4130,0x00},\
	{0x23FE, 0xC056,0x00},\
	{0x3232, 0xFC0C,0x00},\
	{0x3236, 0xFC22,0x00},\
	{0x3238, 0xFCFC,0x00},\
	{0x323A, 0xFD84,0x00},\
	{0x323C, 0xFD08,0x00},\
	{0x3246, 0xFCD8,0x00},\
	{0x3248, 0xFCA8,0x00},\
	{0x324E, 0xFCB4,0x00},\
	{0x326A, 0x8302,0x00},\
	{0x326C, 0x830A,0x00},\
	{0x326E, 0x0000,0x00},\
	{0x32CA, 0xFC28,0x00},\
	{0x32CC, 0xC3BC,0x00},\
	{0x32CE, 0xC34C,0x00},\
	{0x32D0, 0xC35A,0x00},\
	{0x32D2, 0xC368,0x00},\
	{0x32D4, 0xC376,0x00},\
	{0x32D6, 0xC3C2,0x00},\
	{0x32D8, 0xC3E6,0x00},\
	{0x32DA, 0x0003,0x00},\
	{0x32DC, 0x0003,0x00},\
	{0x32DE, 0x00C7,0x00},\
	{0x32E0, 0x0031,0x00},\
	{0x32E2, 0x0031,0x00},\
	{0x32E4, 0x0031,0x00},\
	{0x32E6, 0xFC28,0x00},\
	{0x32E8, 0xC3BC,0x00},\
	{0x32EA, 0xC384,0x00},\
	{0x32EC, 0xC392,0x00},\
	{0x32EE, 0xC3A0,0x00},\
	{0x32F0, 0xC3AE,0x00},\
	{0x32F2, 0xC3C4,0x00},\
	{0x32F4, 0xC3E6,0x00},\
	{0x32F6, 0x0003,0x00},\
	{0x32F8, 0x0003,0x00},\
	{0x32FA, 0x00C7,0x00},\
	{0x32FC, 0x0031,0x00},\
	{0x32FE, 0x0031,0x00},\
	{0x3300, 0x0031,0x00},\
	{0x3302, 0x82CA,0x00},\
	{0x3304, 0xC164,0x00},\
	{0x3306, 0x82E6,0x00},\
	{0x3308, 0xC19C,0x00},\
	{0x330A, 0x001F,0x00},\
	{0x330C, 0x001A,0x00},\
	{0x330E, 0x0034,0x00},\
	{0x3310, 0x0000,0x00},\
	{0x3312, 0x0000,0x00},\
	{0x3314, 0xFC94,0x00},\
	{0x3316, 0xC3D8,0x00},\
	{0x0A00, 0x0000,0x00},\
	{0x0E04, 0x0012,0x00},\
	{0x002E, 0x1111,0x00},\
	{0x0032, 0x1111,0x00},\
	{0x0022, 0x0008,0x00},\
	{0x0026, 0x0040,0x00},\
	{0x0028, 0x0017,0x00},\
	{0x002C, 0x09CF,0x00},\
	{0x005C, 0x2101,0x00},\
	{0x0006, 0x09DE,0x00},\
	{0x0008, 0x0ED8,0x00},\
	{0x000E, 0x0100,0x00},\
	{0x000C, 0x0022,0x00},\
	{0x0A22, 0x0000,0x00},\
	{0x0A24, 0x0000,0x00},\
	{0x0804, 0x0000,0x00},\
	{0x0A12, 0x0CC0,0x00},\
	{0x0A14, 0x0990,0x00},\
	{0x0074, 0x09D8,0x00},\
	{0x0076, 0x0000,0x00},\
	{0x051E, 0x0000,0x00},\
	{0x0200, 0x0400,0x00},\
	{0x0A1A, 0x0C00,0x00},\
	{0x0A0C, 0x0010,0x00},\
	{0x0A1E, 0x0CCF,0x00},\
	{0x0402, 0x0110,0x00},\
	{0x0404, 0x00F4,0x00},\
	{0x0408, 0x0000,0x00},\
	{0x0410, 0x008D,0x00},\
	{0x0412, 0x011A,0x00},\
	{0x0414, 0x864C,0x00},\
	{0x021C, 0x0001,0x00},\
	{0x0C00, 0x9950,0x00},\
	{0x0C06, 0x0021,0x00},\
	{0x0C10, 0x0040,0x00},\
	{0x0C12, 0x0040,0x00},\
	{0x0C14, 0x0040,0x00},\
	{0x0C16, 0x0040,0x00},\
	{0x0A02, 0x0100,0x00},\
	{0x0A04, 0x014A,0x00},\
	{0x0418, 0x0000,0x00},\
	{0x012A, 0xFFFF,0x00},\
	{0x0120, 0x0046,0x00},\
	{0x0122, 0x0376,0x00},\
	{0x0746, 0x0050,0x00},\
	{0x0748, 0x01D5,0x00},\
	{0x074A, 0x022B,0x00},\
	{0x074C, 0x03B0,0x00},\
	{0x0756, 0x043F,0x00},\
	{0x0758, 0x3F1D,0x00},\
	{0x0B02, 0xE04D,0x00},\
	{0x0B10, 0x6821,0x00},\
	{0x0B12, 0x0120,0x00},\
	{0x0B14, 0x0001,0x00},\
	{0x2008, 0x38FD,0x00},\
	{0x326E, 0x0000,0x00},\
	{0x0900, 0x0300,0x00},\
	{0x0902, 0xC319,0x00},\
	{0x0914, 0xC109,0x00},\
	{0x0916, 0x061A,0x00},\
	{0x0918, 0x0407,0x00},\
	{0x091A, 0x0A0B,0x00},\
	{0x091C, 0x0E08,0x00},\
	{0x091E, 0x0A00,0x00},\
	{0x090C, 0x0427,0x00},\
	{0x090E, 0x0069,0x00},\
	{0x0954, 0x0089,0x00},\
	{0x0956, 0x0000,0x00},\
	{0x0958, 0xCA80,0x00},\
	{0x095A, 0x9240,0x00},\
	{0x0F08, 0x2F04,0x00},\
	{0x0F30, 0x001F,0x00},\
	{0x0F36, 0x001F,0x00},\
	{0x0F04, 0x3A00,0x00},\
	{0x0F32, 0x025A,0x00},\
	{0x0F38, 0x025A,0x00},\
	{0x0F2A, 0x4124,0x00},\
	{0x006A, 0x0100,0x00},\
	{0x004C, 0x0100,0x00},\
}

struct hi846_wb_calibration_t {
	uint16_t R_gain;
	uint16_t B_gain;
	uint16_t G_gain;
};

static struct hi846_wb_calibration_t hi846_wb_calibration = {0};
static uint8_t hi846_otp_verified = 0;
static uint16_t otp_data[2745];

static int32_t hi846_otp_write_init_setting0(struct msm_sensor_ctrl_t *s_ctrl)
{
	struct msm_camera_i2c_reg_array init_setting[] = HI846_INIT_SETTING0;
	struct msm_camera_i2c_reg_setting write_setting;
	int32_t rc = 0;

	write_setting.addr_type = MSM_CAMERA_I2C_WORD_ADDR;
	write_setting.data_type = MSM_CAMERA_I2C_WORD_DATA;
	write_setting.delay = 0;
	write_setting.size = sizeof(init_setting) / sizeof(struct msm_camera_i2c_reg_array);
	write_setting.reg_setting = init_setting;

	rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write_table(s_ctrl->sensor_i2c_client, &write_setting);
	if (rc < 0) {
		pr_err("%s:%d: i2c write failed : init setting\n", __func__, __LINE__);
		return rc;
	}

	return rc;
}

static int32_t hi846_otp_write_init_setting1(struct msm_sensor_ctrl_t *s_ctrl)
{
	struct msm_camera_i2c_reg_array init_setting[] = HI846_INIT_SETTING1;
	struct msm_camera_i2c_reg_setting write_setting;
	int32_t rc = 0;

	write_setting.addr_type = MSM_CAMERA_I2C_WORD_ADDR;
	write_setting.data_type = MSM_CAMERA_I2C_WORD_DATA;
	write_setting.delay = 0;
	write_setting.size = sizeof(init_setting) / sizeof(struct msm_camera_i2c_reg_array);
	write_setting.reg_setting = init_setting;

	rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write_table(s_ctrl->sensor_i2c_client, &write_setting);
	if (rc < 0) {
		pr_err("%s:%d: i2c write failed : init setting\n", __func__, __LINE__);
		return rc;
	}

	return rc;
}

static int32_t hi846_otp_init(struct msm_sensor_ctrl_t *s_ctrl)
{
	int32_t rc = 0;
	struct msm_camera_i2c_reg_setting write_setting;
	struct msm_camera_i2c_reg_array init_setting[] =
	{
		{0x0A02,0x01,0},//Fast sleep on
		{0x0A00,0x00,100},//stand by on
		{0x0F02,0x00,0},//pll disable
		{0x071A,0x01,0},//CP TRIM_H
		{0x071B,0x09,0},//IPGM TRIM_H
		{0x0D04,0x01,0},
		{0x0D00,0x07,0},
		{0x003E,0x10,0},
		{0x0A00,0x01,0},//stand by off
	};

	//write sensor init setting
	rc = hi846_otp_write_init_setting0(s_ctrl); 
	if ( rc < 0)
		return rc;

	rc = hi846_otp_write_init_setting1(s_ctrl);
	if ( rc < 0)
		return rc;

	//wrtie otp init setting
	write_setting.addr_type = MSM_CAMERA_I2C_WORD_ADDR;
	write_setting.data_type = MSM_CAMERA_I2C_BYTE_DATA;
	write_setting.delay = 0;
	write_setting.size = sizeof(init_setting) / sizeof(struct msm_camera_i2c_reg_array);
	write_setting.reg_setting = init_setting;

	rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write_table(s_ctrl->sensor_i2c_client, &write_setting);
	if (rc < 0) {
		pr_err("%s:%d: i2c write failed : otp initial\n", __func__, __LINE__);
		return rc;
	}

	return rc;
}

static int32_t hi846_otp_continous_read(struct msm_sensor_ctrl_t *s_ctrl, uint16_t addr_S, uint16_t addr_E)
{
	int32_t rc = 0;
	uint32_t i = 0;
	uint16_t data;

	rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(s_ctrl->sensor_i2c_client,
		0x070A, ((addr_S >> 8) & 0xFF), MSM_CAMERA_I2C_BYTE_DATA);
		if (rc < 0)
	{
		pr_err("%s i2c write failed : %d addr = 0x070A", __func__, __LINE__);
		return rc;
	}

	rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(s_ctrl->sensor_i2c_client,
		0x070B, (addr_S & 0xFF), MSM_CAMERA_I2C_BYTE_DATA);

	if (rc < 0)
	{
		pr_err("%s i2c write failed : %d addr = 0x070B", __func__, __LINE__);
		return rc;
	}

	rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(s_ctrl->sensor_i2c_client,
		0x0702, 0x01, MSM_CAMERA_I2C_BYTE_DATA);
	if (rc < 0)
	{
		pr_err("%s i2c write failed : %d addr = 0x0702", __func__, __LINE__);
		return rc;
	}
		
	for ( i = 0 ; i <= (SEG3_GROUP3_E-SEG1_FLAG_REG); i++)
	{
		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_read(s_ctrl->sensor_i2c_client,
			0x0708, &data, MSM_CAMERA_I2C_BYTE_DATA);
		otp_data[i] = data;
		CDBG(" %s otp_data[0x%x] = 0x%x, %d ", __func__, (i + 0x0201), otp_data[i], i);
		if (rc < 0)
		{
			pr_err("%s i2c read failed : %d addr=0x%x", __func__, __LINE__, i+0x201);
			return rc;
		}
	}

	return rc;
}

static int32_t hi846_otp_checksum_verify(struct msm_sensor_ctrl_t *s_ctrl)
{
	int32_t rc = 0;
	uint16_t seg1_st,seg1_ed,seg2_st,seg2_ed,seg3_st,seg3_ed;
	uint32_t i = 0;
	uint32_t sum = 0;

	if (otp_data[SEG1_FLAG_REG] == 0x01 && otp_data[SEG2_FLAG_REG] == 0x01 && otp_data[SEG3_FLAG_REG] == 0x01)
	{
		seg1_st = SEG1_GROUP1_S;
		seg1_ed = SEG1_GROUP1_E;
		seg2_st = SEG2_GROUP1_S;
		seg2_ed = SEG2_GROUP1_E;
		seg3_st = SEG3_GROUP1_S;
		seg3_ed = SEG3_GROUP1_E;
	}
	else if (otp_data[SEG1_FLAG_REG] == 0x13 && otp_data[SEG2_FLAG_REG] == 0x13 && otp_data[SEG3_FLAG_REG] == 0x13)
	{
		seg1_st = SEG1_GROUP2_S;
		seg1_ed = SEG1_GROUP2_E;
		seg2_st = SEG2_GROUP2_S;
		seg2_ed = SEG2_GROUP2_E;
		seg3_st = SEG3_GROUP2_S;
		seg3_ed = SEG3_GROUP2_E;
	}
	else if (otp_data[SEG1_FLAG_REG] == 0x37 && otp_data[SEG2_FLAG_REG] == 0x37 && otp_data[SEG3_FLAG_REG] == 0x37)
	{
		seg1_st = SEG1_GROUP3_S;
		seg1_ed = SEG1_GROUP3_E;
		seg2_st = SEG2_GROUP3_S;
		seg2_ed = SEG2_GROUP3_E;
		seg3_st = SEG3_GROUP3_S;
		seg3_ed = SEG3_GROUP3_E;
	}
	else 
	{
		pr_err("%s seg_flag error",__func__);
		return -1;
	}

	CDBG("%s group flag = 0x%x", __func__ , otp_data[SEG1_FLAG_REG]);
	CDBG("%s available address: 0x%x,0x%x,0x%x,0x%x,0x%x,0x%x", __func__,
		seg1_st+0x201,seg1_ed+0x201,seg2_st+0x201,seg2_ed+0x201,seg3_st+0x201,seg3_ed+0x201);

	for ( i = seg1_st ; i < seg1_ed ; i++)
	{
		sum += otp_data[i];
		CDBG("%s seg1 otp_data[0x%x] = 0x%x", __func__ , i+0x201, otp_data[i]);
	}
	if ( otp_data[seg1_ed] != (sum % 0xFF +1))
	{
		pr_err("%s seg1 checksum failed, checksum = 0x%x, calu_sum = 0x%x", __func__, otp_data[seg1_ed], sum);
		return -1;
	}

	sum = 0;
	for ( i = seg2_st ; i < seg2_ed ; i++)
	{
		sum += otp_data[i];
		if (( (i -seg2_st) % 2) == 0)
		CDBG("%s seg2 lsc_otp_data[0x%x] = 0x%x", __func__, i+0x201, ((otp_data[i] << 8) | otp_data[i+1]));
		//CDBG("%s seg2 otp_data[0x%x] = 0x%x", __func__ , i+0x201, otp_data[i]);
	}
	if ( otp_data[seg2_ed] != (sum % 0xFF +1))
	{
		pr_err("%s seg2 checksum failed, checksum = 0x%x, calu_sum = 0x%x", __func__, otp_data[seg2_ed], sum);
		return -1;
	}

	sum = 0;
	for ( i = seg3_st ; i < seg3_ed ; i++)
	{
		sum += otp_data[i];
		CDBG("%s seg3 otp_data[0x%x] = 0x%x", __func__ , i+0x201, otp_data[i]);
	}
	if ( otp_data[seg3_ed] != (sum % 0xFF +1))
	{
		pr_err("%s seg3 checksum failed, checksum = 0x%x, calu_sum = 0x%x", __func__, otp_data[seg3_ed], sum);
		return -1;
	}

	return rc;
}
static int32_t hi846_otp_get_info(struct msm_sensor_ctrl_t *s_ctrl)
{
	int32_t rc = 0;

	rc = hi846_otp_continous_read(s_ctrl, 0x0201, 0x0CB9);
	if ( rc < 0)
	{
		pr_err("%s failed", __func__);
		return rc;
	}

	rc = hi846_otp_checksum_verify(s_ctrl);
	if ( rc < 0)
	{
		pr_err("%s failed , checksum error", __func__);
		return rc;
	}

	return rc;
}

static int32_t hi846_otp_wb_calibration(struct msm_sensor_ctrl_t *s_ctrl)
{
	int32_t rc = 0;

	pr_err("%s, cal awb R_gain =0x%x, B_gain=0x%x, G_gain =0x%x \n",__func__ ,
		hi846_wb_calibration.R_gain,hi846_wb_calibration.B_gain,hi846_wb_calibration.G_gain);

	rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(s_ctrl->sensor_i2c_client,
		0x0078, (hi846_wb_calibration.G_gain >> 8), MSM_CAMERA_I2C_BYTE_DATA);
	rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(s_ctrl->sensor_i2c_client,
		0x0079, (hi846_wb_calibration.G_gain & 0xFF), MSM_CAMERA_I2C_BYTE_DATA);
	rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(s_ctrl->sensor_i2c_client,
		0x007A, (hi846_wb_calibration.G_gain >> 8), MSM_CAMERA_I2C_BYTE_DATA);
	rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(s_ctrl->sensor_i2c_client,
		0x007B, (hi846_wb_calibration.G_gain & 0xFF), MSM_CAMERA_I2C_BYTE_DATA);
	rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(s_ctrl->sensor_i2c_client,
		0x007C, (hi846_wb_calibration.R_gain >> 8), MSM_CAMERA_I2C_BYTE_DATA);
	rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(s_ctrl->sensor_i2c_client,
		0x007D, (hi846_wb_calibration.R_gain & 0xFF), MSM_CAMERA_I2C_BYTE_DATA);
	rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(s_ctrl->sensor_i2c_client,
		0x007E, (hi846_wb_calibration.B_gain >> 8), MSM_CAMERA_I2C_BYTE_DATA);
	rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(s_ctrl->sensor_i2c_client,
		0x007F, (hi846_wb_calibration.B_gain & 0xFF), MSM_CAMERA_I2C_BYTE_DATA);

	return rc;
}

int32_t hi846_otp_func(struct msm_sensor_ctrl_t *s_ctrl)
{
	int32_t rc = 0;
	if (hi846_otp_verified  == 0)
	{
		rc = hi846_otp_init(s_ctrl);

		if ( rc < 0)
		{
			pr_err("%s failed", __func__);
			return rc;
		}
		rc = hi846_otp_get_info(s_ctrl);
		if ( rc < 0)
		{
			pr_err("%s failed", __func__);
			return rc;
		}
		hi846_otp_wb_calculation(s_ctrl);

		hi846_otp_verified = 1;
	}
	else
	{
		rc = hi846_otp_wb_calibration(s_ctrl);
	}
	return rc;
}

void hi846_otp_wb_calculation(struct msm_sensor_ctrl_t *s_ctrl)
{
	uint8_t module_id;
	uint16_t R_Gr, B_Gb;
	uint16_t R_Gr_typical, B_Gb_typical;
	uint16_t R_gain = 0x200;
	uint16_t B_gain = 0x200;
	uint16_t G_gain = 0x200;	

	switch (otp_data[SEG1_FLAG_REG])
	{
		case 0x01:
			module_id = otp_data[SEG1_GROUP1_S];
			break;
		case 0x13:
			module_id = otp_data[SEG1_GROUP2_S];
			break;
		case 0x37:
			module_id = otp_data[SEG1_GROUP3_S];
			break;
		default:
			break;
	}

	pr_err("%s module_id = 0x%x", __func__ , module_id);
	s_ctrl->sensordata->sensor_info->module_id = module_id;

	if ( module_id == MODULE_ID_SUNWIN)
	{
		switch (otp_data[SEG3_FLAG_REG])
		{
			case 0x01:
				R_Gr = (otp_data[SEG3_GROUP1_S] << 8) | otp_data[SEG3_GROUP1_S+1];
				B_Gb = (otp_data[SEG3_GROUP1_S+2] << 8) | otp_data[SEG3_GROUP1_S+3];
				break;
			case 0x13:
				R_Gr = (otp_data[SEG3_GROUP2_S] << 8) | otp_data[SEG3_GROUP2_S+1];
				B_Gb = (otp_data[SEG3_GROUP2_S+2] << 8) | otp_data[SEG3_GROUP2_S+3];
				break;
			case 0x37:
				R_Gr = (otp_data[SEG3_GROUP3_S] << 8) | otp_data[SEG3_GROUP3_S+1];
				B_Gb = (otp_data[SEG3_GROUP3_S+2] << 8) | otp_data[SEG3_GROUP3_S+3];
				break;
			default:
				break;
		}

		pr_err("%s module is SUNWIN", __func__ );
		R_Gr_typical = R_GR_TYPICAL_SUNWIN;
		B_Gb_typical = B_GB_TYPICAL_SUNWIN;

	} 
	else if (module_id == MODULE_ID_SBX)
	{
		switch (otp_data[SEG2_FLAG_REG])
		{
			case 0x01:
				R_Gr = (otp_data[SEG3_GROUP1_S] << 8) | otp_data[SEG3_GROUP1_S+1];
				B_Gb = (otp_data[SEG3_GROUP1_S+2] << 8) | otp_data[SEG3_GROUP1_S+3];
				R_Gr_typical = (otp_data[SEG3_GROUP1_S+6] << 8) | otp_data[SEG3_GROUP1_S+7];
				B_Gb_typical = (otp_data[SEG3_GROUP1_S+8] << 8) | otp_data[SEG3_GROUP1_S+9];
				break;
			case 0x13:
				R_Gr = (otp_data[SEG3_GROUP2_S] << 8) | otp_data[SEG3_GROUP2_S+1];
				B_Gb = (otp_data[SEG3_GROUP2_S+2] << 8) | otp_data[SEG3_GROUP2_S+3];
				R_Gr_typical = (otp_data[SEG3_GROUP2_S+6] << 8) | otp_data[SEG3_GROUP2_S+7];
				B_Gb_typical = (otp_data[SEG3_GROUP2_S+8] << 8) | otp_data[SEG3_GROUP2_S+9];
				break;
			case 0x37:
				R_Gr = (otp_data[SEG3_GROUP3_S] << 8) | otp_data[SEG3_GROUP3_S+1];
				B_Gb = (otp_data[SEG3_GROUP3_S+2] << 8) | otp_data[SEG3_GROUP3_S+3];
				R_Gr_typical = (otp_data[SEG3_GROUP3_S+6] << 8) | otp_data[SEG3_GROUP3_S+7];
				B_Gb_typical = (otp_data[SEG3_GROUP3_S+8] << 8) | otp_data[SEG3_GROUP3_S+9];
				break;
			default:
				break;
		}	

		pr_err("%s module is SBX", __func__ );
	}
	else
	{
		pr_err("%s module id error!return ", __func__ );
		hi846_wb_calibration.R_gain = 0x200;
		hi846_wb_calibration.B_gain = 0x200;
		hi846_wb_calibration.G_gain = 0x200;
		return;
	}

	CDBG("%s R_Gr=0x%x, B_Gb=0x%x, R_Gr_typical=0x%x, B_Gb_typical=0x%x",
		__func__, R_Gr, B_Gb, R_Gr_typical, B_Gb_typical);

	R_gain = 0x200 * R_Gr_typical / R_Gr;
	B_gain = 0x200 * B_Gb_typical / B_Gb;

	if (R_gain < B_gain)
	{
		if (R_gain < 0x200)
		{
			B_gain = 0x200 * B_gain/R_gain;
			G_gain = 0x200 * G_gain/R_gain;
			R_gain = 0x200;
		}
	}
	else
	{
		if (B_gain < 0x200)
		{
			R_gain = 0x200 * R_gain/B_gain;
			G_gain = 0x200 * G_gain/B_gain;
			B_gain = 0x200;
		}
	}

	hi846_wb_calibration.R_gain = R_gain;
	hi846_wb_calibration.B_gain = B_gain;
	hi846_wb_calibration.G_gain = G_gain;

	pr_err("%s R_gain = 0x%x, B_gain=0x%x, G_gain=0x%x", __func__,R_gain, B_gain, G_gain);

	return;
}
 //ZTEMT: zhouruoyu add for hi846 otp ---end